#include <algorithm>
#include <cstdint>
#include <fstream>
#include <iostream>
#include <list>
#include <string>
#include <vector>

#include <cstdlib> // rand()

// Device-under-test model generated by CXXRTL:
#include "dut.cpp"
#include "hw/ppu_regs.h"
#include <backends/cxxrtl/cxxrtl_vcd.h>

static const unsigned int MEM_SIZE = 16 * 1024 * 1024;
uint8_t mem[MEM_SIZE];

const char *help_str =
"Usage: tb binfile [--vcd vcdfile] [--dumpframe frame.tga] [--display width height]\n"
"    binfile                : Binary to load into start of memory\n"
"    --vcd vcdfile          : Dump waves to vcdfile\n"
"    --display width height : Configure PPU DISPSIZE and set size of frame dump\n"
"    --frame frame.tga      : Dump 1 frame's worth of PPU output to frame.tga\n";

void exit_help(std::string errtext = "") {
	std::cerr << errtext << help_str;
	exit(-1);
}

int main(int argc, char **argv) {

	if (argc < 2)
		exit_help();

	bool dump_waves = false;
	std::string waves_path;
	bool dump_frame = false;
	std::string frame_path;
	std::vector<std::pair<uint32_t, uint32_t>> dump_ranges;
	int frame_width = 320;
	int frame_height = 240;

	for (int i = 2; i < argc; ++i) {
		std::string s(argv[i]);
		if (s == "--display") {
			if (argc - i < 3)
				exit_help("Option --display requires 2 arguments\n");
			frame_width = std::stoul(argv[i + 1], 0, 0);
			frame_height = std::stoul(argv[i + 2], 0, 0);
			i += 2;
		}
		else if (s == "--vcd") {
			if (argc - i < 2)
				exit_help("Option --vcd requires an argument\n");
			dump_waves = true;
			waves_path = argv[i + 1];
			i += 1;
		}
		else if (s == "--frame") {
			if (argc - i < 2)
				exit_help("Option --frame requires an argument\n");
			dump_frame = true;
			frame_path = argv[i + 1];
			i += 1;
		}
		else {
			exit_help("Unrecognised argument\n");
		}
	}

	cxxrtl_design::p_riscboy__ppu top;

	std::fill(std::begin(mem), std::end(mem), 0);

	std::ifstream fd(argv[1], std::ios::binary | std::ios::ate);
	std::streamsize bin_size = fd.tellg();
	if (bin_size > MEM_SIZE) {
		std::cerr << "Binary file (" << bin_size << " bytes) is larger than memory (" << MEM_SIZE << " bytes)\n";
		return -1;
	}
	fd.seekg(0, std::ios::beg);
	fd.read((char*)mem, bin_size);

	std::ofstream waves_fd;
	cxxrtl::vcd_writer vcd;
	if (dump_waves) {
		waves_fd.open(waves_path);
		cxxrtl::debug_items all_debug_items;
		top.debug_info(all_debug_items);
		vcd.timescale(1, "us");
		vcd.add(all_debug_items);
	}

	std::vector<uint16_t> framebuf;
	unsigned int scanout_x = 0;
	unsigned int scanout_y = 0;

	bool bus_trans = false;
	bool bus_write = false;
	uint32_t bus_addr = 0;
	uint8_t bus_size = 0;
	// Never generate bus stalls
	top.p_mem__addr__rdy.set<bool>(true);

	static const int mem_latency = 2;
	std::pair<bool, uint32_t> mem_reqs[mem_latency];
	for (int i = 0; i < mem_latency; ++i) {
		mem_reqs[i] = std::pair<bool, uint32_t>(false, 0);
	}
	int next_mem_req = 0;

	// Reset + initial clock pulse
	top.step();
	top.p_clk.set<bool>(true);
	top.step();
	top.p_clk.set<bool>(false);
	top.p_rst__n.set<bool>(true);
	top.step();

	std::list<uint16_t> waddr_seq;
	std::list<uint32_t> wdata_seq;
	// Generate vsync at correct point
	waddr_seq.push_back(PPU_DISPSIZE_OFFS);
	wdata_seq.push_back(((unsigned int)frame_height - 1) << PPU_DISPSIZE_H_LSB);
	// Pass in program entry point
	waddr_seq.push_back(PPU_CPROC_PC_OFFS);
	wdata_seq.push_back(0);
	// Start running, no halt condition
	waddr_seq.push_back(PPU_CSR_OFFS);
	wdata_seq.push_back(PPU_CSR_RUN_MASK);

	bool sim_halt = false;
	int cycle;
	for (cycle = 0; !sim_halt && cycle < 1000000; ++cycle) {
		top.p_clk.set<bool>(false);
		top.step();
		if (dump_waves)
			vcd.sample(cycle * 2);
		top.p_clk.set<bool>(true);
		top.step();
		top.step();

		// Provide a response for the memory access that was issued n cycles ago
		uint16_t rdata = 0;
		bool rdata_valid = false;
		std::pair<bool, uint32_t> mem_req_pop = mem_reqs[next_mem_req];
		if (mem_req_pop.first) {
			rdata_valid = true;
			rdata =
				(uint32_t)mem[(mem_req_pop.second << 1)] |
				mem[(mem_req_pop.second << 1) + 1] << 8;
		}
		top.p_mem__rdata.set<uint16_t>(rdata);
		top.p_mem__rdata__vld.set<bool>(rdata_valid);

		// Push the current memory access to the history ring buffer so we will
		// process it in n cycles
		mem_reqs[next_mem_req] = std::pair<bool, uint32_t>(
			top.p_mem__addr__vld.get<bool>(),
			top.p_mem__addr.get<uint32_t>()
		);
		next_mem_req = (next_mem_req + 1) % mem_latency;

		// Process configuration register writes
		if (!waddr_seq.empty() && !wdata_seq.empty() && !top.p_apbs__psel.get<bool>()) {
			top.p_apbs__pwrite.set<bool>(true);
			top.p_apbs__psel.set<bool>(true);
			top.p_apbs__paddr.set<uint16_t>(waddr_seq.front());
			top.p_apbs__pwdata.set<uint32_t>(wdata_seq.front());
			waddr_seq.pop_front();
			wdata_seq.pop_front();
		}
		else if (top.p_apbs__psel.get<bool>() && !top.p_apbs__penable.get<bool>()) {
			top.p_apbs__penable.set<bool>(true);
		}
		else if (top.p_apbs__psel.get<bool>()) {
			top.p_apbs__penable.set<bool>(false);
			top.p_apbs__psel.set<bool>(false);
		}

		// Scanbuffer client
		if (top.p_scanout__ren.get<bool>()) {
			// Collect any read from the previous cycle
			framebuf.push_back(top.p_scanout__rdata.get<uint16_t>());
		}
		if (top.p_scanout__buf__rdy.get<bool>()) {
			if (scanout_x >= frame_width) {
				scanout_x = 0;
				top.p_scanout__ren.set<bool>(false);
				top.p_scanout__buf__release.set<bool>(true);
				++scanout_y;
				if (scanout_y >= frame_height)
					sim_halt = true;
			}
			else {
				top.p_scanout__buf__release.set<bool>(false);
				top.p_scanout__ren.set<bool>(true);
				top.p_scanout__raddr.set<uint16_t>(scanout_x);
				++scanout_x;
			}
		}
		else {
			top.p_scanout__buf__release.set<bool>(false);
		}

		if (dump_waves) {
			// The extra step() is just here to get the bus responses to line up nicely
			// in the VCD (hopefully is a quick update)
			top.step();
			vcd.sample(cycle * 2 + 1);
			waves_fd << vcd.buffer;
			vcd.buffer.clear();
		}
	}

	std::cout << "Ran for " << (cycle + 1) << " cycles\n";

	if (dump_frame) {
		std::ofstream ofile(frame_path, std::ios::binary);
		uint8_t tga_header[18] = {0};
		tga_header[2] = 0x02; // Uncompressed
		tga_header[10] = tga_header[14] = frame_height & 0xff;
		tga_header[11] = tga_header[15] = frame_height >> 8;
		tga_header[12] = frame_width & 0xff;
		tga_header[13] = frame_width >> 8;
		tga_header[16] = 0x18; // 24 bpp
		tga_header[17] = 0x20; // set direction bits as we have top-left origin
		ofile.write((const char*)tga_header, 18);
		std::vector<uint8_t> framebuf_888;
		for (int i = 0; i < frame_width * frame_height; ++i) {
			uint16_t pix_rgb565 = framebuf[i];
			framebuf_888.push_back((pix_rgb565 & 0x001fu) << 3); // B
			framebuf_888.push_back((pix_rgb565 & 0x07e0u) >> 3); // G
			framebuf_888.push_back((pix_rgb565 & 0xf800u) >> 8); // R
		}
		ofile.write((const char*)framebuf_888.data(), 3 * frame_width * frame_height);
	}

	return 0;
}
